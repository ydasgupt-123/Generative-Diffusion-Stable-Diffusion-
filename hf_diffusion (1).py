# -*- coding: utf-8 -*-
"""HF Diffusion

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HDuopExTJYeDB0zywZAtI5NYeR33lhlE
"""

pip install tensorflow keras

pip install matplotlib

import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as plt
import numpy as np

(X_train, y_train), (X_test, y_test) = keras. datasets.mnist.load_data()
X_train = X_train.astype("float32") / 255.0
X_test  = X_test.astype("float32") / 255.0

X_train = X_train[..., np.newaxis]
X_test  = X_test[..., np.newaxis]

plt.imshow(X_train[5],cmap = 'Greys')

def corrupt(x, amount):
  noise = np.random.rand(*x.shape)
  # The 'amount' should directly scale the image, ensuring it's between 0 and 1 for scaling.
  return x*(1-amount) + noise*amount

# Use an amount between 0 and 1 for scaling, for example 0.5 to reduce intensity by half.

plt.imshow(corrupt(X_train[5], 0.9), cmap = 'Greys')

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import Input, Dense, Concatenate, Flatten
from tensorflow.keras.models import Model, Sequential

class BasicUnet(tf.keras.layers.Layer):
  def __init__(self, in_channels = 1, out_channels = 1):
    super().__init__()
    self.down_layers = [
        tf.keras.layers.Conv2D(32, kernel_size=5, padding = 'same'),
        tf.keras.layers.Conv2D(64, kernel_size=5, padding = 'same'),
        tf.keras.layers.Conv2D(64, kernel_size=5, padding = 'same'),
    ]
    self.up_layers = [
        tf.keras.layers.Conv2D(64, kernel_size = 5, padding = 'same'),
        tf.keras.layers.Conv2D(32, kernel_size = 5, padding = 'same'),
        tf.keras.layers.Conv2D(out_channels, kernel_size = 5, padding = 'same'),
    ]
    self.act = tf.keras.layers.Activation('swish')
    self.downscale = tf.keras.layers.MaxPool2D(2)
    self.Upscale = tf.keras.layers.UpSampling2D(size=(2,2), interpolation='nearest')

  def call (self, x):
    h = []
    for i, l in enumerate(self.down_layers):
      x = self.act(l(x))
      if i < 2:
        h.append(x)
        x = self.downscale(x)
    for i, l in enumerate (self.up_layers):
      if i > 0:
        x = self.Upscale(x)
        x = x + h.pop()
      x = self.act(l(x))

    return x

inputs = tf.keras.Input(shape=(28, 28, 1))
unet_layer = BasicUnet() # Instantiate the layer
outputs = unet_layer(inputs) # Call the layer instance with the input tensor

model = tf.keras.Model(inputs=inputs, outputs=outputs)
model.summary()


X_noisy = corrupt(X_train, 0.9)
model.compile(optimizer = 'adam', loss = 'mse', metrics = ['mae'])

model.fit(X_noisy, X_train, epochs = 10)

model.evaluate(corrupt(X_test,0.9), X_test)